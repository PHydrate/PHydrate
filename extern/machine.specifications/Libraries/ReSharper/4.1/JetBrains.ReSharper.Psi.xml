<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.ReSharper.Psi</name>
    </assembly>
    <members>
        <member name="T:JetBrains.ReSharper.Psi.AccessibilityDomain">
            <summary>
            The accessibility domain of some type member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PUBLIC">
            <summary>
            Unrestricted access to member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.INTERNAL">
            <summary>
            Access is restricted to assembly, in which member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_OR_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/>, all it derivates, and the assembly where member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_AND_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates in assembly where member is declared
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PRIVATE">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> only
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.NONE">
            <summary>
            Error occured while computing accessibility domain
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CachePersistenceSettingsManager.GetGlobalCacheFolder">
            <summary>
            Get the cache folder for global entities. 
            The value is <c>null</c> if do not use global cache - everything should be stored in solution
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope">
            <summary>
            Repsents scope of declarations cache.
            Scope can be one of :
            <list>
            <item>whole solution including libraries - covers types and namespaces in solution</item>
            <item>whole solution exclusing libraries - covers types and namespaces in source code of solution</item>
            <item>project - covers types and namespaces in source code of given project</item>
            <item>project and its referenced libraries and projects- covers types and namespaces in given project and its references including transitive ones</item>
            <item>library and its referenced libraries - covers types and namespaces in given library and libraries referenced by it</item>
            </list>
            Methods of this class are static constructors allowing creation of different scopes listed above.
            <example>See <see cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache"/> for example of use.</example>
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">DeclarationsCache</seealso>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope.SolutionScope(JetBrains.ProjectModel.ISolution,System.Boolean)">
            <summary>
            Creates whole solution or solution without libraries scope.
            </summary>
            <remarks>solution should not be <code>null</code></remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope.ProjectScope(JetBrains.ProjectModel.IProject,System.Boolean)">
            <summary>
            Creates project scope or project and its referenced libraries and projects scope.
            </summary>
            <remarks>project should not be <code>null</code></remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope.LibraryScope(JetBrains.ProjectModel.IAssembly,System.Boolean)">
            <summary>
            Creates library and its referenced libraries scope.
            </summary>
            <remarks>library should not be null <code>null</code></remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope.ModuleScope(JetBrains.ProjectModel.IModule,System.Boolean)">
            <summary>
            Creates library and its referenced libraries scope.
            </summary>
            <remarks>library should not be null <code>null</code></remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">
            <summary>
            Declarations cache provides access to cached information about types and namespaces.
            Depending on its scope declarations cache may provide information about types and namespaces
            <list>
            <item>in whole solution including libraries</item>
            <item>in whole solution exclusing libraries</item>
            <item>in project</item>
            <item>in project and its referenced libraries and projects</item>
            <item>in library and its referenced libraries</item>
            </list>
            </summary>
            <example>
            Following code demonstates use of <see cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">IDeclarationsCache</see> indexer
            to get information about given class.
            <code>
            bool ClassIsSealed(string qualifiedName, ISolution solution)
            {
              DeclarationsCacheScope scope = DeclarationsCacheScope.SolutionScope(solution, false);
              IDeclarationsCache cache = PsiManager.GetInstance(solution).GetDeclarationsCache(scope);
              IDeclaredElementInfo info = cache[qualifiedName];
              Logger.Assert(info.GetSymbolType() == DeclaredElementType.CLASS);
              return info.IsSealed();
            }
            </code>
            </example>
            <seealso cref="T:JetBrains.ReSharper.Psi.Caches.DeclarationsCacheScope">DeclarationsCacheScope</seealso>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredElement">IDeclaredElementInfo</seealso>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetElementsAtQualifiedName(System.String)">
            <summary>
            Takes cached information about namespace or type with given <paramref name="qualifiedName">qualified name</paramref>
            and returns array with cached information about its nested namespaces and types
            (or just types if qualified name is a typename).
            </summary>
            <param name="qualifiedName">Full qualified name of namespace or type</param>
            <remarks>Returns information about default namespace if empty string is passed.
            <code>null</code> should not be passed (throws NullReferenceException).</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">
            <summary>
            Returnes array of short names of all namespaces and types.
            Short name of a type is its declared name. Short name of a namespace is 
            last part of its name without dot, e.g. in the following code
            <code>
            namespace A.B
            {
            }
            </code>
            short name of namespace A.B is B.
            </summary>
            <returns>Lexicographically sorted array of all short names of namespaces and types.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetElementsByShortName(System.String)">
            <summary>
            Returns array of cached information about namespaces and types having given short name.
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <remarks>Empty arrray is returned if no elements with given name are found.
            Empty array is returned if <code>null</code> is passed.</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetPossibleInheritors(System.String)">
            <summary>
            Returns array of cached information about types that might directly inherit type
            with given short name. Type A is supposed that it might directly inherit type B if 
            it contains reference that might resolve to B in its extends list.
            Reference might resolve to type B if its name is short name of type B.
            GetPossibleInheritors takes aliases into consideration.
            <example>
            <code>
            using X = B;
            class A : B {}
            </code>
            Cached information for type A will be returned in calls to GetPossibleInheritors for type B.
            (And for type X if any exists in this declarations cache scope).
            </example>
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <param name="shortTypeName">short name of type</param>
            <remarks><paramref name="shortTypeName">short type name</paramref> should not be null</remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.Item(System.String)">
            <summary>
            Returns cached information about namespace or type with given <paramref name="qualifiedName">qualified name</paramref>.
            Returns <code>null</code> if no information for given name was found.
            </summary>
            <param name="qualifiedName">Full qualified name of namespace or type</param>
            <remarks>Returns special value if empty string is passed.
            <code>null</code> should not be passed (throws NullReferenceException).
            </remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.WordIndex">
             <summary>
             Allows retrieving project items corresponding to source files 
             containing identifiers with given names.
             This index can be used to narrow search operations on JetBrains.ReSharper.Psi.CSharp.
             </summary>
             <example>
             Example demostrates narrowing of search domain:
             <code>
            ISearchDomain NarrowSearchDomain (ISearchDomain searchDomain, IDeclaredElement elementToSearch)
            {
              WordIndex wordIndex = WordIndex.GetInstance (elementToSearch.GetManager().Solution );
              IProjectItem [] itemsContainingNames = wordIndex.GetFilesContainingWords (elementToSearch.ShortName);
              ISearchDomain newDomain = SearchDomainFactory.CreateSearchDomain (itemsContainingNames);
              return SearchDomainFactory.CreateIntersectionDomain (searchDomain,newDomain);
            }
             </code>
             <seealso cref="T:JetBrains.ReSharper.Psi.Search.IFinder"/>
             </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.WordIndex.GetInstance(JetBrains.ProjectModel.ISolution)">
            <summary>
            Returns instance of word index for given solution.
            </summary>
            <param name="solution"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.WordIndex.GetFilesContainingWord(System.String)">
            <summary>
            Returns array of project items corresponding to all source code files 
            containing identifiers which text is equal to given word
            </summary>
            <param name="word"></param>
            <remarks>Returns empty array if empty array is passed or no such files found.
            Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.WordIndex.GetFilesContainingWords(System.String[])">
            <summary>
            Returns array of project items corresponding to all source code files 
            containing identifiers which text is equal to any of given words
            </summary>
            <remarks>Returns empty array if empty array is passed or no such files found.
            Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.WordIndex.GetWords(System.String,JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWordIndexLanguageProvider)">
            <summary>
            Splits the text to the words using given provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeAnnotationsCache.GetStringFormatMethodParameter(JetBrains.ReSharper.Psi.IMethod)">
            <summary>
            Get the format parameter of the string format method. Returns <c>null</c> if method is not string format method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.FormatFile(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the whole file
            </summary>
            <returns>new caret position</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given range in the tree. The bounding nodes are random, not siblings
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.Format(JetBrains.ProjectModel.ISolution,JetBrains.DocumentModel.DocumentRange,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given range in document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.FormatInsertedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.FormatInsertedRange(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ITreeRange)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.FormatReplacedNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.FormatDeletedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.Optimize(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.IPsiRangeMarker,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Optimize imports and shorten references in file
            </summary>
            <param name="file"></param>
            <param name="rangeMarker">Range in document to process. Pass <see cref="F:JetBrains.DocumentModel.DocumentRange.InvalidRange"/> to process whole file</param>
            <param name="optimizeUsings"></param>
            <param name="shortenReferences"></param>
            <param name="progressIndicator"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatter.GetSeparatorBetween(JetBrains.ReSharper.Psi.Tree.ITokenNode,JetBrains.ReSharper.Psi.Tree.ITokenNode)">
            <summary>
            Create the necessary separator between two given tokens (for example. space between identifiers)
            If there is no necessity for separator, then return <c>null</c>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings">
            <summary>
            The component-like holder for all code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings.FileHeaderText">
            <summary>
            Get the copyright header of the file. Empty string means no copyright info
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings.FileHeaderRegionName">
            <summary>
            Get if the copyright notice should be embraced in region. Empty region name means no embracement
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsAttribute">
            <summary>
            Specific code style settings (for specific language, for example) should be marked 
            by this attribute to be included in the code style settings container
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsManager">
            <summary>
            Component which is responsible to managing global code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsManager.CodeStyleSettings">
            <summary>
            Current code style settings container
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.USER">
            <summary>
            Code style settings are pre user
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.SOLUTION">
            <summary>
            Code style settings are shared in solution
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.EXTERNAL">
            <summary>
            Code style settings are serialized to  external file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.SolutionCodeStyleSettings">
            <summary>
            Per-solution code style settings management
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1">
            <summary>
            Represents <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> for presentations.
            </summary>
            <remarks>Provides ability to keep <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation when element becomes invalid</remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredElementEnvoy.IsValid">
            <summary>
            Gets value indicating if underlying declared element is valid
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1.Text">
            <summary>
            Gets presentation text for declared element, as was last generated via <see cref="M:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1.Present``1(JetBrains.UI.TreeView.StructuredPresenter{``0,JetBrains.CommonControls.IPresentableItem},``0,JetBrains.CommonControls.IPresentableItem,JetBrains.UI.TreeView.PresentationState)"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1.IsValid">
            <summary>
            Gets value indicating if underlying declared element is valid
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.GetProjectFiles">
            <summary>
            Get the set of project files which contains the declaration of this element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsInProjectFile(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Checks if there are declarations of this element in given <paramref name="projectFile"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredElement.Language">
            <summary>
            Get the language on which this element is declared
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IConstantValueOwner.ConstantValue">
            <summary>
            Calculate compile time constant value 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint">
            <summary>
            Represents an expectation constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.Accepts(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if a type matches the constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultType">
            <summary>
            Gets some default appropriate type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultTypes">
            <summary>
            Gets some default appropriate types
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetTypesEffectively">
            <summary>
            Gets array of expected types if can be performed effeciently 
            </summary>
            <returns>
              null  if ineffective
              array of types if fast
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.CollectionTypeUtil.ElementTypeByCollectionType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns element type if collectionType is a _collection_type_ (described in specification, 15.8.4)
            otherwise, returns null
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromConstraint">
            <summary>
            Constraint implementation which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ConvertibleFromExpressionTypeConstraint">
            <summary>
            Constraint implementation which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleToConstraint">
            <summary>
            Constraint implementation which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedType">
            <summary>
            Represents an expectation based on expression context
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IsSubtypeOfConstraint">
            <summary>
            Accepts types which inherit from the specified type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.JoinConstraint">
            <summary>
            Joins multiple constraints (a type matches joined constraint 
            if it matches at least one of nested constraints)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ReferenceTypeConstraint">
            <summary>
            Constraint which accepts only reference types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.SuperTypeConstraint">
            <summary>
            Constraint which accepts only super types of  a given type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetSuperTypes">
            <summary>
            Immediate supertypes of the type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetMembers">
            <summary>
            returns all members of this type (including nested types!)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetMembers(System.String)">
            <summary>
            returns all members of this type (including nested types!) with given name
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetContainingNamespace">
            <summary>
            Namespace containing this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.CLRName">
            <summary>
            Get the CLR name of type element.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.NestedTypes">
            <summary>
            returns all nested (= inner) types of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Constructors">
            <summary>
            returns all constructors of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Operators">
            <summary>
            returns all operators of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Methods">
            <summary>
            returns all methods of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Properties">
            <summary>
            returns all properties of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Events">
            <summary>
            returns all events of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.AllTypeParameters">
            <summary>
            returns the enumerator through type parameters of this type and all container types
            </summary>
            Type parameters are enumerated in right-to-left, nested class first order
            In the following example
            <code>
            class A&lt;X,Y&gt;
            {
               class B&lt;Z,W&gt; {}
            }
            </code>
            AllTypeParameters for class B will be enumerated in order W,Z,Y,X
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IModifiersOwner">
            <summary>
            Interface for a language construction that may have modifiers
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IAccessRightsOwner">
            <summary>
            Interface for a language construction that may have access rights modifiers
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeMember.GetHiddenMembers">
            <summary>
            Find the members in supertypes which are hidden by this member
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.AccessibilityDomain">
            <summary>
            Returns the accessibility domain of the type member, taking into account 
            the accessibility of the containing types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.HidePolicy">
            <summary>
            Get the hide policy
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IParametersOwner">
            <summary>
            Represents a function-like construct that can be invoked.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Signature of the invocable. 
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.InvocableSignature"/>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.Parameters">
            <summary>
            Set of formal parameters of the invocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.ReturnType">
            <summary>
            Return type of the invocable 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IInterface.CanBeInstantiated">
            <summary>
            Indicates if the interface can be instantiated using object creation expression
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IStruct.HasHiddenInstanceFields">
            <summary>
            Returns <c>true</c> if struct not all fields are returned in <see cref="P:JetBrains.ReSharper.Psi.IStruct.Fields"/> property.
            This could happen since private fields are not loaded through metadata
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart">
            <summary>
            Base class for language-dependent cached type decls
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part">
            <summary>
            a node of cache tree 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part.SetParent(JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part)">
            <summary>
            Sets parent. Always use the method to set parent
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.DeclarationPart.AssignDeclaredElement(JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2)">
            <summary>
            Implementations should override this method to bind their declarations to their declared elements
            </summary>
            <param name="declaration"></param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiTransactionAction.ProjectFile">
            <summary>
            Corresponding to PSI, that is changed
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart.WriteCustom(JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWriter)">
            <summary>
            Override this method to read custom data
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IExplicitImplementation">
            <summary>
            Reference to <see cref="T:JetBrains.ReSharper.Psi.IOverridableMember"/> explicit interface implementation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExplicitImplementation.Resolve">
            <summary>
            Resolve
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.DeclaringType">
            <summary>
            interface which contains implemented member
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.MemberName">
            <summary>
            Name of implemented member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Dependencies.IUsingsInfo">
            Implementors of this interface should have constructor with no parameters
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.InvocationCandidate">
            <summary>
            An invocation target candidate for invocation context
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespaceRegistrar.myMap">
            keys are normalized qnames
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.INKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "in" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.FROMKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "from" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <summary>
            Tries to cut a long string with <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/> by replacing some of the closing parameters with "...".
            </summary>
            <param name="presenter"></param>
            <param name="str">"Long" string containing a presentation of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <param name="marking">Marking of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <returns><code>true</code> if succeds to shorten a string.</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking">
            <summary>
            This class describes positions of different components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            This class is used as <code>out</code> parameter in calls to <see cref="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/> methods.
            See <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/> methods for examples of use.
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.EntityKindRange">
            <summary>
            The declared element entity kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.AccessRightsRange">
            <summary>
            The declared element access rights range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ModifiersRange">
            <summary>
            The declared element modifier words range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeRange">
            <summary>
            The declared element type (for variables) or return type (for functions) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ScalarTypeRange">
            <summary>
            The declared element scalar type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "int [] x" the scalar type range of "x" is the range of "int".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ExplicitInterfaceRange">
            <summary>
            Range of the explicit interface qualification of the member.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.NameRange">
            <summary>
            The declared element name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterListRange">
            <summary>
            The declared element parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterListRange">
            <summary>
            The declared element type parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterRanges">
            <summary>
            An array of the declared element type parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterRanges">
            <summary>
            An array of the declared element parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerRange">
            <summary>
            The declared element container (type or namespace) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            //TODO: what it returns for parameter?
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerNameRange">
            <summary>
            The range of the name of the container.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ConstantValueRange">
            <summary>
            The range of the value of a constant or a local constant in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter">
            <summary>
            This class describes position of parameter-related components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            An instance of this class is stored in the marking per each parameter of the formatted <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.Range">
            <summary>
            The paramter range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.KindRange">
            <summary>
            The paramter kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.TypeRange">
            <summary>
            The paramter type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.ScalarTypeRange">
            <summary>
            The range of scalar type of the parameter type in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "void Foo(int [] x)" the scalar type range of parameter "x" is the range of "int".
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.NameRange">
            <summary>
            The paramter name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementType">
            <summary>
            Type of the declared element. Each type should be singleton
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.PresentableName">
            <summary>
            Presentable name of the declared element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.Image">
            <summary>
            Image of the declared element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.DefaultPresenter">
            <summary>
            Default declared element presenter
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IOverridableMember">
             <summary>
             Presents type member, that could be overridden. Currently overridable members are method,
             property, indexer and event.
             <list type="number">
             <item> SuperMember for class (struct) overridable member "foo" is class member that is overridden
                by "foo" or interface member that is implemented by "foo".
                
                Interface member cannot have supermembers. </item>
                
             <item> If "A" is a class, "I" is an interface, both "A" and "I" contains member "foo", class "B" extends
                "A" and implements "I", but "A" does not contain member "foo",
                then "I.foo" is QuasiSuperMember fo "A.foo"</item>
            
             <item> Let "A.foo" is supermember for "B.foo". If there is no "C.foo" such that "C.foo" is
                supermember for "B.foo" and "A.foo" is supermember foe "C.foo", then "A.foo" is immediate
                supermember for "B.foo".
            
                <para>All interface members are immediate supermembers.</para>
                <para>All quasisupermembers are immediate (quasi)supermembers.</para> </item>
                
             <item> If "A.foo" is supermember for "B.foo" and "A.foo" has no supermembers, then "A.foo" is root
                supermember for "B.foo".
                <para>All interface members are root supermembers.</para>
                <para>All quasisupermembers are root (quasi)supermembers.</para> </item>
             </list>
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.IsExplicitImplementation">
            <summary>
            Returns <c>true</c> if this member is private implementation. See <see cref="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations">
            <summary>
            Returns the list of the members which are implemented explicitly
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.CanBeImplicitImplementation">
            <summary>
            Returns true if this member can implement interface member implicitly
            </summary>
            Language-dependent property of IOverridableMember. Reflection implementations should return true.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ISubstitution">
            <summary>
            Implements a valuation of type parameters
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ISubstitution.Compose(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>Substitution composition: s.Compose([t->T]) = [t->s(T)]</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.TextOccurenceSearcherBase.Predicate">
            <summary>
            Get the predicate to check if the given node should be checked for text occurence
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ICustomHandler">
            <summary>
            Base interface for language-specific custom handlers in write PSI and generated documents
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec">
            <summary>
            Part of the PSI write interface. 
            Provides the functionality to re-bind references when the subtree is inserted into physical tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.Encode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Encode the references from the <paramref name="original"/> tree into the <paramref name="clone"/> tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.Decode">
            <summary>
            Decode the references when the clone is inserted into the real tree, and returns the clone position in the tree
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSubtreeInserted">
            <summary>
            Occurs when clone subtree is inserted into target, but reference identity is not yet started
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetReferenceIdentity">
            <summary>
            Occurs during encoding when reference identity is set
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnReferenceBinded">
            <summary>
            Occurs during decoding after reference was binded
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetDeclarationIdentity">
            <summary>
            Called once after encoding and gices the match table between local declarations
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.myLocalDeclarations">
            <summary>
            Map from declared elements in <see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.myOriginal"/> subtree into declaration in <see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.myClone"/> subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.ExtractBindableReferences(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Try to extract reference from given element which could be bind
            </summary>
            <param name="element">Element to extract reference from</param>
            <returns>Array of references to the element itself (i.e. C in A.B.C), or empty array if no bindable reference found</returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.DecodeProcessor.myLocalDeclarations">
            <summary>
            Map from declared elements in <see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.myOriginal"/> subtree into declaration in <see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecBase.myClone"/> subtree
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.CascadingCache.myData">
            <summary>
            Data in this level of cache
            </summary>
            - No value for key means "look upstream if there is upstream, otherwise recalculate" 
            - Other value is calculated value
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.CascadingCache.Recall(System.Object,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.CalculationProcess@)">
            <summary>
            Returns cached value for key, or FORGET if recalculation is required
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness">
            <summary>
            Determines whether static members are accessible in this context.
            </summary>
            Staticness should be consistent with qualifier kind of access context.
            All qualifier 
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetElement">
            <summary>
            Returns the "owner" (tail) of the reference.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetName">
            <summary>
            Returns reference name.
            This name usually coincides with short name of corresponding DeclaredElement.
            (Only known exception is constructor initializer, its name is "this" or "base".)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAllNames">
            <summary>
            Returns all reference names (i.e., all possible short names of corresponding DeclaredElement)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetReferenceSymbolTable(System.Boolean)">
            <summary>
            Returns full symbol table for the reference
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.Resolve">
            <summary>
            todo[dsl]: must write
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange">
            <summary>
            Returns text range of reference in the source file.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.CheckResolveResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Bind this reference to given Declared Element. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Bind this reference to given Declared Element and substitution. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAccessContext">
            <summary>
            Returns access context containing reference. It is useful to define, if context
            is static or to determine access rights of context.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.ReferenceType">
            <summary>
            
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.HasMultipleNames">
            <summary>
            Returns true iff reference could be resolved in declared elements with different names.
            E.g., attribute [XXX] could be resolved into class with name 'XXX' or 'XXXAttribute' 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.LocalNamesFilter">
            <summary>
            Prefer symbols defined in given assembly if their FQN is the same
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IQualifier.GetSymbolTable(System.String[])">
            <param name="referenceNames">
            Names of the reference, for which the symbol table is built. 
            Array is empty if the table should not be filtered.
            </param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IQualifier.Resolved">
            <summary>
            False means failed to resolve
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IDocCommentReference.TagName">
            <summary>
            Tag name in which this reference occurs
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetContainingElement``1(System.Boolean)">
            <param name="returnThis">Whether to include the starting element.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.Contains(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Returns true if the subtree rooted at this element contains other element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.IsPhysical">
            <summary>
            Checks if this element is located at physical file (and not in dummy holder).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.Copy(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            Use <see cref="M:JetBrains.ReSharper.Psi.Util.MiscUtil.CopyElement``1(``0,JetBrains.ReSharper.Psi.Tree.IElement)"/> for strongly-typed variant
            </summary>
            <param name="context">context for resolving, or <c>null</c> for none</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.CopyWithResolve">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            All references in the copy are fake-resolved.
            Use <see cref="M:JetBrains.ReSharper.Psi.Util.MiscUtil.CopyElementWithResolve``1(``0)"/> for strongly-typed variant
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.IsValid">
            <summary>
            Checks if this element is valid
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetDocumentRange">
            <summary>
            Get the coordinates of this subtree in real document
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetNavigationRange">
            <summary>
            Returns an offset in the text to move caret to when positioning to the element
            </summary>
            <returns>An offset in the text</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindElementAt(JetBrains.Util.TextRange)">
            <summary>
            Finds the smallest element containing the specified text range
            </summary>
            <param name="treeTextRange">Text range in this element</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindElementsAt(System.Int32)">
            <summary>
            Finds all elements containing the specified offset and such that none of the elements
            contains another element meeting this condition
            </summary>
            <param name="treeTextOffset">Offset to find element at</param>
            <returns>Array of found elements, or an empty array</returns>
            <remarks>If an element returned by this method is not a leaf, it should be empty</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindTokenAt(System.Int32)">
            <summary>
            Returns the token containing the character corresponding to the specified offset
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindReferencesAt(JetBrains.Util.TextRange)">
            <summary>
            Finds all references whose ranges in text contain the specified text range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetText(System.Text.StringBuilder)">
            <return> Implementations must always return parameter.</return>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetText">
            <summary>
            Returns text representation of an element
            </summary>
            <remarks>For performance reason, it's better to use another GetText method</remarks>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.PutPersistentData``1(JetBrains.Util.Key{``0},``0)">
            <summary>
            Stores given value by specified key. This value will be copied to clones
            Use <code>PutPersistentData(key, null)</code> to remove the association.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetPersistentData``1(JetBrains.Util.Key{``0})">
            <summary>
            Retrieves value associated with given key.
            Returns null when no value is associated.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IExpression.Type">
            <summary>
            Type of expression. This function never returns null, if type cannot be determined
            it returns UnknownType.Instance.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.GetAllNames">
            <summary>
            Override this method if your reference has muiltiple names
            </summary>    
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.HasMultipleNames">
            <summary>
            Override this method if your reference has muiltiple names
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.ReSharper.Psi.IExpressionType.IsImplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.PsiLanguageType)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.ReSharper.Psi.IExpressionType.IsExplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.PsiLanguageType)" -->
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type in which all names are shown in fully qualified form. 
            For example, for "System.Drawing.Point[]" it will be "System.Drawing.Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: long presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetManager">
            <summary>
            Get the PSI manager
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsResolved">
            <summary>
            Check if the type is resolved successfully (and it's substitution is resolved correctly)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsUnknown">
            <summary>
            Check if this type is unknown, i.e. it can't have correct presentation
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsValid">
            <summary>
            Check if this type is valid, i.e. referes to valid declared elements
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.Job.Do(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Runs the task. The <paramref name="progress"/> should be used only if the task requires additional progress display (like smooth execution progress or more text messages). Normally, for short-time tasks, the executing engine will handle the progress.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.Description">
            <summary>
            The individual description of the job. Not included into the status bar cache notifier.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.GroupId">
            <summary>
            Common ID for the group of jobs.
            It's the group progress that is displayed in the cache notifier, not jobs'.
            The group ID is displayed as the cache notifier main text (the only text of the status-bar cache notifier).
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress">
            <summary>
            If a cache job wants to display more detailed progress while it's running, it can request a <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>-based object from the <see cref="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread"/>.
            It must be <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>-ed before the job ends.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.myNotifier">
            <summary>
            The owning notifier to which our display goes.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.myThread">
            <summary>
            Thread affinity.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.Disable(System.String)">
            <summary>
            Disables the progress when each job ends.
            </summary>
            <param name="sJobIdentity">The job identity, so that to include its name in error messages.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.Enable(System.Double,System.Double,System.String)">
            <summary>
            Enables the progress while a job is running, mapping it to the range occupied by the job.
            </summary>
            <param name="rangestart">Subprogress range.</param>
            <param name="rangelength">Subprogress range.</param>
            <param name="sJobIdentity">The job identity, so that to include its name in error messages.</param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.DelegateJob">
            <summary>
            A cache thread work item, implemented by a delegate.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.DelegateJob.#ctor(JetBrains.Util.Runnable,System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="runnable">Job implementation.</param>
            <param name="name">Name for the job, to be displayed in the cache notifier.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.TakeOwnership(System.Object)">
            <summary>
            Sets the ownership over the notifier, so that it could not be modified without a cookie.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.WaitForCaches(System.String,System.String)">
            <summary>
            Syncroniously wait until caches are ready, with a popup progress window.
            Must be called under a read lock.
            </summary>
            <param name="sCallerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="sCancelButtonContent">Title of the Cancel button, or <c>Null</c> if the Cancel button should be disabled.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Description">
            <summary>
            The additional (verbose comment) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Header">
            <summary>
            The main (title) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.IsActive">
            <summary>
            Whether the cache notifier is current active.
            This means it should be visible on the screen, in either form, if additional conditions are met (eg VS window is active).
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Progress">
            <summary>
            The progress value for the cache notifier, must be in the [0…1] range.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.FindTokenAt(JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Returns the token containing the character corresponding to the specified offset
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.FindReferencesAt(JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Finds all references whose ranges in document contain the specified range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.ReParse(JetBrains.Util.TextRange,System.String)">
            <summary>
            Incrementally reparse file
            </summary>
            <param name="modifiedRange">range in the old file text which is changed</param>
            <param name="text">text which should replace given range</param>
            <returns>the new file (may be the same)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.GetDocumentRange(JetBrains.Util.TextRange)">
            <summary>
            Translate the specified range in syncronized text into actual document range
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.GetIntersectingRanges(JetBrains.Util.TextRange)">
            <summary>
            Get all ranges in actual document which intersects with given range in syncronized text
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.Translate(JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Translate coordinates in actual document into range in syncronized text
            </summary>
            <param name="documentRange"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.ToTreeNode">
            <summary>
            The same as <see cref="M:JetBrains.ReSharper.Psi.Tree.IElement.ToTreeNode"/> but with different return type.
            Just for convenience.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ProjectFile">
            <summary>
            Returns project item containing this source element
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.CachingLexer">
            <summary>
            Obtains the caching lexer on file text
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ParsedDocument">
            <summary>
            The document, that is parsed to the tree
            This is either the generated code-behind document, or the real document
            <para>
            NOTE: Under PSI transaction this is still the original document, though it's contents doesn't correspobd to PSI tree
            </para>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ModificationCounter">
            <summary>
            Starting from 0, each time the subtree is modified this counter increases
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ControlFlow2.Impl.ControlFlowGrafInspector.ElementInspectionData.GetContext(JetBrains.ReSharper.Psi.ControlFlow2.IControlFlowRib)">
            <summary>
            Context could slightly differ depending on which exit it is transited
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ControlFlow2.Impl.ControlFlowGrafInspector.ElementInspectionData.Context">
            <summary>
            Context after inspection of given element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ControlFlow2.Impl.ControlFlowGrafInspector.ElementInspectionData.ModificationStamp">
            <summary>
            Modification stamp for inspection
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IType">
            <summary>
            Represents a type. 
            Instances of <c>IType</c> can be compared by <see cref="M:System.Object.Equals(System.Object)"/> and are equal 
            if they represent the same type.
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IArrayType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IPointerType"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type. 
            For example, for "System.Drawing.Point[]" it will be "Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
            <seealso cref="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetScalarType">
            <summary>
            Returns type of the scalar value of this type.
            For examples for "int", "int[]", "int[][]" and "int*" it returns "int".
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.IsWellFormed">
            <summary>
            Checks whether values of all type parameters satisfies their constrains
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.IsOpenType">
            <summary>
            According to C# specs 25.5.2
            <list type="bullet">
            <item>type parameter defines an open type</item>
            <item>An array type is an open type if and only if its element type is an open type</item>
            <item>A constructed type is an open type if and only if one or more of its type arguments is an open type. A
              constructed nested type is an open type if and only if one or more of its type arguments or the type
              arguments of its containing type(s) is an open type</item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.Classify">
            <summary>
            Get the type kind. Returns <c>null</c> is can't classify this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.Module">
            <summary>
            Get the module where this type was built
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <param name="element">Contains <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> to provide string presentation of.</param>
            <param name="marking">Returns the markup of the string with a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation.</param>
             <summary>
             Returns a string containing declared element text presentation made according to this presenter settings.
             This method is usefull when additional processing is required for the returned string,
             e.g. as is done in the following method:
             <code>
             RichText Foo(IMethod method)
             {
               DeclaredElementPresenterMarking marking;
               RichTextParameters rtp = new RichTextParameters(ourFont);
               // make rich text with declared element presentation
               RichText result = new RichText(ourInvocableFormatter.Format(method, out marking),rtp);
               // highlight name of declared element in rich text
               result.SetColors(SystemColors.HighlightText,SystemColors.Info,marking.NameRange.StartOffset,marking.NameRange.EndOffset);
               return result;
             }
             </code>
             </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.ParameterKind)">
            <summary>
            Returns language specific presentation for a given parameter kind 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.AccessRights)">
            <summary>
            Returns language specific presentation for a given access rights value
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessProjectItem(JetBrains.ProjectModel.IProjectFile)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessElement(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessLibraryFile(JetBrains.ReSharper.Psi.Caches.ILibraryFile)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.TypeElementEqualityComparer">
            <summary>
            Check if given type elements equal.
            This will check possible runtime binding, i.e. 2 type elements from assemblies equals if their FQN equals, and assembly names are the same
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming2.Elements.INamedElementsManager.GetAllElementKinds(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <param name="language">'null' for language neutral element kinds</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming2.Elements.NamedElementsBagAttribute.#ctor(System.String)">
            <param name="languageType">'null' for cross language elements</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming2.Elements.NamedElementsManager.GetAllElementKinds(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <param name="language">'null' for language neutral element kinds</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming2.Extentions.NameChangeUtil.GetSuggestedName(JetBrains.ReSharper.Psi.Naming2.NameRoot,JetBrains.ReSharper.Psi.Naming2.NameRoot,JetBrains.ReSharper.Psi.Naming2.NameRoot)">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming2.NameWord.ourSkipTailInfix">
            <summary>
            ElementOfPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming2.NameWord.ourPredefinedPrefixes">
            <summary>
            GetPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming2.NameWord.ourCollectionSuffixes">
            <summary>
            ElementList -> Element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistentCache`2.Load(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Returns false in the following cases:
              - cache directory does not exist
              - cache format version did not match
              - one or more record's CRC did not match
              - total cache CRC did not match
              - IO problem occured
            In all these cases it automatically resets the cache on the disk to an empty one.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MiscUtil.MostEncompassedType(JetBrains.ReSharper.Psi.IType[],JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
            <param name="types"></param>
            <param name="languageType"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MiscUtil.MostEncompassingType(JetBrains.ReSharper.Psi.IType[],JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Select the single type in the collection, to which all others are implicitly convertible
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MiscUtil.SortDeclarationsByWritability(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.IDeclaration},JetBrains.ReSharper.Psi.Tree.IDeclaration)">
            <summary>
            Sorts declarations array. If you want to perform write operation, write to the first item of the sorted array.
            </summary>
            <param name="declarations">Array with declarations to sort.</param>
            <param name="declaration">Declaration to which you would particulary like to write to. Pass null if you do not care.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MiscUtil.IsIgnoredField(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Returns true if marked with __ReSharperIgnoredField attribute
            The field should not be added to the class' symbol table if it is already added from base class
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.IGeneratedCodeRegionDetector">
            <summary>
            Should be used in copperation with recursive element processor to check generated code regions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.IGNORE">
            <summary>
            Do not optimize this reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.SIGNATURE">
            <summary>
            Reference is signature reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.CODE_BLOCK">
            <summary>
            Reference is in code block
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptimizeImportsServiceProvider.GetReferenceType(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference,JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Check if the given reference is located in code block, or in delcaration level
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.Optimize(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.IPsiRangeMarker,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Do optimize imports and shorten references. 
            Parameter <paramref name="rangeMarker"/> specifies range in file which is 
            affected by the process, or set it to <see cref="F:JetBrains.DocumentModel.DocumentRange.InvalidRange"/> 
            to process whole file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector">
            <summary>
            Collect and sort references which are affected bu optimze imports engine
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector.Collect(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference)">
            <summary>
            Returns true, if qualifier should not be visited
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PredefinedOperator.#ctor(JetBrains.ReSharper.Psi.PsiLanguageType,System.String,JetBrains.ReSharper.Psi.IType,System.Int32)">
            <summary>
            For creating operators with common type for parameters and return type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INamingStyle.SuggestVariableNames(JetBrains.ProjectModel.ISolution,System.String,JetBrains.ReSharper.Psi.Naming.DefaultNamingStyle.NamingEntityKind,System.String,System.Boolean)">
            <summary>
            Suggests names for variable of a given type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.DefaultNamingStyle.DefaultNamingStyle.SuggestVariableNames(JetBrains.ProjectModel.ISolution,System.String,JetBrains.ReSharper.Psi.Naming.DefaultNamingStyle.NamingEntityKind,System.String,System.Boolean)">
            <summary>
            Suggests names for variable of a given type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ICompleteableReference.GetCompletionSymbolTable">
            <summary>
            Returns symbol table for code completion
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.ICompleteableReference.CanComplete">
            <summary>
            Checks whether the reference can provide a meaningful symbol table for completion
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeEquationsSolver.SolveSubtyping(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.ITypeParameter},JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Solves an equation of the form <i>from &lt;: to</i>
            </summary>
            Free occurences of type parameters are in 'from'
            <param name="from"></param>
            <param name="to"></param>
            <param name="inferrableTypeParameters"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.ITypeArgumentsOwnerElement">
            <summary>
            Unifies cross-language reference names and reference expressions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.EffectiveBaseClass(JetBrains.ReSharper.Psi.ITypeParameter,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.ITypeParameter})">
            <summary>
            </summary>
            <remarks>
            See corrected algorithm:
            https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=281842
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.MostEncompassedType(JetBrains.ReSharper.Psi.IType[])">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.IsNullableType(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if the given type is Nullable
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.GetNullableUnderlyingType(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Get the underlying type of the nullable type.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TreeUtil.FindCommonParentInternal(JetBrains.ReSharper.Psi.Tree.ITreeNode@,JetBrains.ReSharper.Psi.Tree.ITreeNode@,System.Int32,JetBrains.ReSharper.Psi.Tree.ITreeNode@)">
            <summary>
            <paramref name="node1"/> is deeper than <paramref name="node2"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ControlFlow2.Impl.ControlFlowGraf.FixUp">
            <summary>
            Fixup graf into canonical representation. 
            Prepare reachable sequence for inspection and analyze reacability of elements
            Should be called from any inheritor constructor
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiIconManagerImpl">
            <summary>
            Implementation for <see cref="T:JetBrains.ReSharper.Psi.PsiIconManager"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconManager">
            <summary>
            Abstract interface for building model icon managers
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetDummyImage">
            <summary>
            Get the empty image of the typical size
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.PsiLanguageType,System.Boolean)">
            <summary>
            Gets image for declared element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType,JetBrains.ReSharper.Psi.PsiIconExtension)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.ExtendToTypicalSize(System.Drawing.Image)">
            <summary>
            Extends the specified node image (16x16) to typical size
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiIconManager.TypicalImageSize">
            <summary>
            Gets typical size of images produced by the manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IElementInstancePointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCache.GetCachedFile(JetBrains.ProjectModel.IAssembly)">
            <summary>
            Tries to load cached PSI for given assembly. Returns <c>null</c> if cached PSI does not exist or out of date
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCache.SaveFileInCache(JetBrains.ProjectModel.IAssembly,JetBrains.ReSharper.Psi.Caches.ILibraryFile,JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyDataCache)">
            <summary>
            Save loaded PSI in caches
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCache.SaveXMLDocIndexInCache(JetBrains.ProjectModel.IAssembly,JetBrains.Util.FileSystemPath,JetBrains.ReSharper.Psi.Impl.Reflection2.XMLDocIndex)">
            <summary>
            Save XML documentation index in caches
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.ConstructorSpecialReferenceSearcher">
            <summary>
            Search for ":this()", ":base()" references....
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.CreateLexer(JetBrains.ProjectModel.ProjectFileType,JetBrains.Util.IBuffer)">
            <summary>
            Creates lexer, that corresponds to source file text (NOT generated!) 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDerivedProjectFileLanguageService">
            <summary>
             The interface is used, when extension does not identify ProjectFileType 	unambiguously
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ProjectFileLanguageServiceAttribute.Extensions">
            <summary>
            File extensions, that identify ProjectFileType
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ProjectFileLanguageServiceAttribute.IsDefault">
            <summary>
            IsDefault means that, the extensions identify the whole group of similar files (i.e. xml)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.DefaultNamingStyle.NameSettings">
            <summary>
            Keeps name settings for an entity
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.INameCanoniser">
            <summary>
            Interface for components performing language-specific canonisation of symbol names. 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalShortName(System.String)">
            <summary>
            Canonises language-specific short name by returning the CLR-compilant equivalent
            </summary>
            <param name="name">Language-specific name (possibly escaped)</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalQualifiedName(System.String)">
            <summary>
            Converts language-specific qualified name into CLR-compliant equivalent
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Name.SplitTextByWords(System.String)">
            <summary>
            Splits string by words and returns array of strings
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.NamingUtil.SuggestVariableNames(JetBrains.ReSharper.Psi.PsiLanguageType,JetBrains.ProjectModel.ISolution,System.String,JetBrains.ReSharper.Psi.Naming.DefaultNamingStyle.NamingEntityKind,System.String,System.Boolean)">
            <summary>
            Suggests names for variable of a given type
            </summary>Part
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.Word">
            <summary>
            Represents a word
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Word.myText">
            <summary>
            Stores the word text
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Word.myCase">
            <summary>
            Stores thr word case style
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Word.ChangeCase(JetBrains.ReSharper.Psi.Naming.WordCase)">
            <summary>
            Returns a copy of the word with the specified case
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Naming.Word.Text">
            <summary>
            Gets the word text
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Naming.Word.Case">
            <summary>
            Gets the word case
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Naming.Word.FormattedText">
            <summary>
            Gets the text formatter with the word case
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.WordCase">
            <summary>
            Enumerates possible case styles of words
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.WordCase.UpperCase">
            <summary>
            The word is <c>UPPERCASE</c>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.WordCase.LowerCase">
            <summary>
            The word is <c>lowercase</c>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.WordCase.CamelCase">
            <summary>
            The word is <c>Camelcase</c>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.WordCase.DontChange">
            <summary>
            Don't change word casing
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconExtension">
            <summary>
            Enumerates possible node types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ElementAccessContext">
            <summary>
            IAccessContext implementation based on element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Search.FindResultRelatedReference">
            <summary>
            Returned when <see cref="F:JetBrains.ReSharper.Psi.Search.SearchPattern.FIND_RELATED_ELEMENTS"/> is set and the related element is found
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.FindNextNode(JetBrains.ReSharper.Psi.Tree.TreeNodePredicate)">
            <summary>
            Returns first tree node satisfying the predicate and located after the current node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.FindPrevNode(JetBrains.ReSharper.Psi.Tree.TreeNodePredicate)">
            <summary>
            Returns first source element satisying the predicate and located before the current element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetNextMeaningfulChild(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns next child which is meaningful in the language (not a comment and not a whitespace)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IConstructor">
            <summary>
            Represents type constructor
            </summary>
            <i>Note</i>: <code>ShortName</code> of all implementations should return 
            <cref>DeclaredElementConstants.CONSTRUCTOR_NAME</cref>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.IDefaultNamespaceOwner">
            <summary>
            This interface is implemented by <see cref="T:JetBrains.ReSharper.Psi.Tree.IFile"/> implementations when there is defaut namespace
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlockNode.GetXML(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Get the XML node for this doc comment, using given DeclaredElement as the header
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlockNode.GetErrors">
            <summary>
            Get errors from XML parsing
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IField.FixedBufferSize">
            <summary>
            In C#2.0 for field, check if this field is fixed-size buffer.
            Returns <c>null</c> if this is not fixed-size buffer, otherwise returns it's size
            If the field is fixed-size buffer, then it's type is a pointer to it's element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetImmediateSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all immediate supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetRootSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all root supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration.QualifiedName">
            <summary>
            Returns qualified name of the namespace this declaration declares
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Returns true if the type is (not necessary immediate) descendant of another type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IChameleonNode.ReSync(JetBrains.ReSharper.Psi.Parsing.CachingLexer,JetBrains.Util.TextRange,System.Int32)">
            <summary>
            Try to incrementally reparse the chameleon block
            </summary>
            <param name="cachingLexer">lexer of the new text</param>
            <param name="changedRange">range in text which is modified</param>
            <param name="insertedTextLen">Length of the inserted portion of the text</param>
            <returns>new chameleon if successfull. null if can't syncronize</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.EntityKindForm">
            <summary>
            Indicates how declared element entity kind is presented:
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show entity kind (default value)</description></item>
            <item><term>NORMAL</term><description>namespace</description></item>
            <item><term>NORMAL_IN_BRACKETS</term><description>(in namespace)</description></item>
            <item><term>IN</term><description>in namespace</description></item>
            <item><term>FROM</term><description>from namespace</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NameStyle">
            <summary>
            Indicates how the entity name shold be presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show name (default value)</description></item>
            <item><term>SHORT</term><description>Show name in short form</description></item>
            <item><term>SHORT_RAW</term><description>Show name in short non-verbatim form</description></item>
            <item><term>QUALIFIED</term><description>Show name in fully qualified form</description></item>
            <item><term>QUALIFIED_EXCEPT_MEMBERS</term><description>Show name in fully qualified form if the element is not type member</description></item>
            <item><term>FULL_NESTED_TYPE</term><description>Full nested type name without namespace</description></item>
            <item><term>FULL_NESTED_TYPE_EXCEPT_MEMBERS</term><description>Full nested type name without namespace if the element is not type member</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeStyle">
            <summary>
            Indicates how return type of a function or type of a variable are presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>BEFORE</term><description>Language default (for example: Type foo)</description></item>
            <item><term>AFTER</term><description>foo:Type</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.MemberContainerStyle">
            <summary>
            Indicates where the container type of a type member should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>foo() in ClassName</description></item>
            <item><term>AFTER_WITH_KIND</term><description>foo() in class ClassName</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>foo() (in ClassName)</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>foo() (in class ClassName)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeContainerStyle">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>ClassName in Namespace</description></item>
            <item><term>AFTER_WITH_KIND</term><description>ClassName in namespace Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>ClassName (in namespace Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ParameterContainerStyle">
            <summary>
            Indicates if the containing method should be shown and where it should be shown if the given element is a parameter.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show method (default value)</description></item>
            <item><term>AFTER</term><description>parameter a of method foo</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>parameter a (of method foo)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NamespaceContainerStyle">
            <summary>
            Indicates if the containing type of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>Namespace in Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>Namespace (in Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeParameterStyle">
            <summary>
            The style of the type parameters presenting.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type parameters</description></item>
            <item><term>CLR</term><description>CLR-style, i.e. the number of type parameters after `</description></item>
            <item><term>FULL</term><description>Show type parameters with their names(default value)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.FormattedLengthCalculator">
            <summary>
            Delagate for custom length checker. Length check is used to replace long parameter lists with "...".
            <see cref="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle"/> is capable of calculating length itself (<see cref="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/>.
            However, if there are other length considerations (e.g. UI limitations) this class may be used.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle">
            <summary>
            This class is a convertor from IDeclaredElement into presentable string with various options.
            </summary>
            Generally this class is used to prepare strings for displaying information to user as is done
            in the following code fragment:
            <code>
            class SomeClass
            {
              private static ourFormatter;
              
              static SomeClass()
              {
                ourFormatter  = new DeclaratedElementPresenter();
                // set desired options
                ourFormatter.ShowParameterTypes = true;
                ourFormatter.ShowParameterNames = true;
                ourFormatter.ShowBrackets = false;
              }
              
              public string[] Display(IDeclaredElement element)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElement : " + ourFormatter.Format(element));
              }
              public string[] Display(IDeclaredElementInfo info)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElementInfo : " + ourFormatter.Format(info));
              }
            }
            </code>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowAccessRights">
            <summary>
            Indicates if we should show acees rights of a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> (if any)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowModifiers">
            <summary>
            Indicates if we should show the modifiers other rhan access rights <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParametersForDelegates">
            <summary>
            Indicates if we should show parameters for a <see cref="T:JetBrains.ReSharper.Psi.IDelegate"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowEntityKind">
            <summary>
            Indicates if the result string should contain element entity kind
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowName">
            <summary>
            Indicates if the result string should contain element name
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeParameters">
            <summary>
            Indicates if type parameters should be shown
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowExplicitInterfaceQualification">
            <summary>
            Indicates if the explicit interface qualification should be shown before type member name
            This option is incompatible with ShowName == NameStyle.QUALIFIED
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNameInQuotes">
            <summary>
            Indicates if the result string should contain element name (including signature, return type, etc.) enclosed in quotes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowType">
            <summary>
            Indicates where and how 
            <list type="bullet">
            <item>type of a variable </item>
            <item>return type of a function</item>
            </list>
            should be inserted into result
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterTypes">
            <summary>
            Indicates if the parameter list of a function should contain parameter types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterNames">
            <summary>
            Indicates if the parameter list of a function should contain parameter names
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypesQualified">
            <summary>
            Indicates if  
            <list type="bullet">
            <item>return type of a function</item>
            <item>parameter types of a function</item>
            <item>type of a variable</item>
            </list>
            should be fully qualified.
            Does not affect <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            To specify qualified names for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> 
            use <see cref="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer"/> property.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowMemberContainer">
            <summary>
            Indicates where the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.MemberContainerQualified">
            <summary>
            Indicates how the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            Workd only if 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNamespaceContainer">
            <summary>
            Indicates if the containing namespace of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterContainer">
            <summary>
            Indicates if the containing method of a <see cref="T:JetBrains.ReSharper.Psi.IParameter"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.IParameter"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthLimit">
            <summary>
            Sets the output string length limit.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthCheck">
            <summary>
            Returns interface for computing output string length
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowConstantValue">
            <summary>
            Indicates if the value of a constant is to be shown.
            Affects only constant.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart">
            <summary>
            Root of cached declarations tree for a file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart.GetRelevantDefines(JetBrains.ReSharper.Psi.PreProcessingDirective[])">
            <summary>
            Returns sorted array
            </summary>
            <param name="defines"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.NamespacePart">
            <summary>
            Base class for language-dependent cached namespace decls
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil.ComputeSubstitution(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Implemenatation of <a cref="!:ITypeElement.GetAncestorSubstitution"/>
            </summary>
            <param name="subtype"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil.FindInheritancePathRecursive(System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.ITypeElement},JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,System.Collections.Generic.List{JetBrains.ReSharper.Psi.Resolve.ISubstitution})">
            Find the type chain from type to subtype
            Returns null if no path is found
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.GeneratedDocumentServiceAttribute">
            <summary>
            Indicates that the marked class provides service for generated code-behind document
            The marked class should be
            <list type="number">
            <item>Interface of the solution-level component</item>
            <item>Implement the <see cref="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService"/></item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.CanHandle(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Checks, whether the file is handled by this service.
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetGeneratedDocument(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.PsiLanguageType@,JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IRangeTranslator@,JetBrains.ReSharper.Psi.Resolve.IReferenceProvider@,JetBrains.ReSharper.Psi.Resolve.ISymbolTableProvider@)">
            <summary>
            Generates document for a file. File should be of correct type.
            </summary>
            <param name="file">Project file</param>
            <param name="language">Language of the generated file</param>
            <returns>Created document. Not null.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.IsDirty(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Checks, whether the file was modifies
            </summary>
            <param name="file"></param>
            <returns>True, if the provider handles the document and it was modified since last commit.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.OnGeneratedDocumentCopyChanged(JetBrains.ProjectModel.IProjectFile,JetBrains.Util.TextRange,System.String,System.String)">
            <summary>
            Called from transaction manager when temporary copy generated document is chaged
            </summary>
            <param name="file">project file for which the document is generated</param>
            <param name="range">replaced range in generated document</param>
            <param name="newText">new text inserted into generated document</param>
            <returns>Transaction action that represents modification in real document</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetDisplayRange(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Custom naviagtion range, for instance for page declarations in ASP
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.StartCommitDocuments">
            <summary>
            Detects changes and applies changes in main thread
            </summary>
            <returns>null means nothing should be done for this service</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.WorkCommitDocuments(System.Object)">
            <summary>
            Performs background work (generate document text)
            </summary>
            <param name="startResult">Return value of StartCommitDocuments</param>
            <returns>null means nothing should be done for this service</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.FinishCommitDocuments(System.Object)">
            <summary>
            Performs document changes on main thread
            </summary>
            <param name="workerResult">Return value of WorkCommitDocuments</param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.AllDocumentsAreComitted">
            <summary>
            Returns true if no dirty items
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.CustomHandler">
            <summary>
            Custom handler for write interface for C#
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ISymbolTable.Names(System.String,System.Boolean,JetBrains.Application.CheckForInterrupt)">
            <summary>
            Get all names from the symbol table, starting from the given prefix <paramref name="prefix"/>. 
            The names are treated case-sensitive <b>only</b> if both <paramref name="caseSensitive"/> and <see cref="P:JetBrains.ReSharper.Psi.Resolve.ISymbolTable.CaseSensitive"/> are <c>true</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable.AddSymbol(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,System.Int32)">
            <summary>
              adds declared symbol into symbol table
            </summary>
            <param name="declaredElement">
              symbol to add into table
            </param>
            <param name="scope">
              visibility scope for added symbol
            </param>
            <param name="level">
              "depth level" of declared symbol
              for imported symbol (class or namespace)                          level = -1
              for namespaces and top-level classes without containing namespace level = 0
              for top-level classes with containing namespace                   level = 1
              for class members (including inner classes)                       level = level of containing class + 1
              for method parameters and local variables                         level = level of containing class + 2
            </param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable.RemoveSymbols(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope)">
            <summary>
              removes all symbols wtih visibility scope = scope
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.WritableSymbolTableBase.AddSymbolInternal(System.String,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,System.Int32,System.Nullable{System.Int32})">
            <summary>
            
            </summary>
            <param name="name">Normalized name</param>
            <param name="element"></param>
            <param name="substitution"></param>
            <param name="scope"></param>
            <param name="level"></param>
            <param name="inheritanceLevel"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterSymbolTable">
            <summary>
            Filters symbol table with multiple filters
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindElementsAtInternal(System.Int32,System.Collections.Generic.List{JetBrains.ReSharper.Psi.Tree.IElement})">
            <returns>Length of this element if it's less or equal than offset or any value greater than offset</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindChameleonWhichCoversRange(JetBrains.Util.TextRange)">
            <summary>
            Finds the deepest sub-node implementing IChameleon interface which contains the given range internally
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.GetOwnAccessibilityDomain">
            This should be overriden in IDeclaredElement implementations
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16)">
            <summary>
            Search for the child with given role
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16,System.Int16)">
            <summary>
            Search for the child with given role. Stop search when child with role <paramref name="stopperRole"/> is found
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.GetNextFilteredChild(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement)">
            <summary>
            To be overriden for each language.     
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.GetIndexByChildAndRole(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement)">
            <summary>
            Returns index of the child of the node among the children with the same role
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecFactory">
            <summary>
            Base class for custom context codec factory.
            Every custom factory should be used only in 'using' statement shell
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.ClosureRemap(JetBrains.ReSharper.Psi.Resolve.IReference)">
            <summary>
            Do chain remap
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.PreviousIdentitySaver">
            <summary>
            User can set previous identity saver, so all events will be propagated to it
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.LowLevelModificationUtil">
            <summary>
            Methods to modify PSI tree with commiting changes to document through PSI manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil">
            <summary>
            Methods to modify PSI tree with reference re-binding
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.ReplaceChild``1(JetBrains.ReSharper.Psi.Tree.ITreeNode,``0)">
            <summary>
            Warning: <paramref name="newChild"/> should not be child of <paramref name="oldChild"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.CreateCopy(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Create the copy of given ITreeNode under DummyHolder. All references are fake resolved
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IArrayType">
            <summary>
            Interface for array types.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.ElementType">
            <summary>
            Obtain type of the array elements.
            Example: returns "int" for "int[]".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.Rank">
            <summary>
            Get the rank (number of dimensions) of the array
            Examples:
              int[]   -> Rank == 1
              int[][] -> Rank == 1 (since it's an array with elements type "int[]")
              int[,]  -> Rank == 2
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDeclaredType">
            <summary>
            Interface for types which might have declaration (that is, correspond to some <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>).
            For example, "IDeclaredType" and "int" are declared types.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredType.GetTypeElement">
            <summary>
            Returns ITypeElement corresponding to this type. 
            Can return null when it cannot "resolve" this type.
            For example, this can happen when you get type of a variable and
            the corresponding type usage in the source code cannot be resolved
            (that is, the code is not compilable).
            </summary>
            <returns>ITypeElement corresponding to this type or null if the type cannot be resolved.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredType.GetCLRName">
            <summary>
            CLR name of the type
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredType.Assembly">
            <summary>
            Assembly name of the assembly where this type is defined, or null if unspecified
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IElementPointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TrivialElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NonPhysicalElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TrivialElementInstancePointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ModifiersOwnerExtension.CanBeOverriden(JetBrains.ReSharper.Psi.IModifiersOwner)">
            <summary>
            Checks if entity either abstract, virtual or override. That is to say, it can be overriden in derived classes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PartsMap.PreprocessorDirectivesIndex.DirectivesAfterLastProjectChange">
            <summary>
            
            </summary>
            Always returns sorted directives
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ICache.Update(System.Collections.Generic.ICollection{JetBrains.ProjectModel.IProjectFile})">
            <summary>
            Synchronously update caches
            </summary>
            Happens either when <see cref="M:JetBrains.ReSharper.Psi.PsiManager.CommitAllDocuments"/> or <see cref="M:JetBrains.ReSharper.Psi.PsiManager.UpdateCaches"/> 
            is called
            <param name="commitedPsi">list of files commited right before updating caches</param>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.SymbolCache.SymbolCache.myShortNamesIndex">
            <summary>
            Dictionary from short name to CacheTrieNode
            If there is only one CacheTrieNode by given short name, then it is located by itself
            If there are multiple CacheTrieNode's then the HashSet with them is located by the name
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.SymbolCache.SymbolCache.GetOrCreateNamespace(System.String)">
            Does not create a namespace yet...
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWordIndexLanguageProvider.CaseSensitiveIdentifiers">
            <summary>
            If usages are case 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread.JobGroupProgressTracker">
            <summary>
            Just tracks the progress within each job group.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread.JobGroupProgressTracker.NextJob(System.Double@,System.Double@)">
            <summary>
            A new job is about to start. Calculates the cache notifier progress position for the job (<paramref name="jobrangestart"/>) and the amount of progress dedicated to this job (<paramref name="jobrangelen"/>).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterUtil.CompareNodesPosition(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Compare the position of two given nodes in the tree
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterUtil.ComputeEndColumnOfNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Calculates the end column of the given node. It is either
             - If node is multiline, the it the length of the first line
             - If the node is singleline, then it is the end position of the node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterUtil.HasTokenBetween(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Check if there are any of the given tokens set between two given nodes in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl.FindMembersInSuperInterfaces(JetBrains.ReSharper.Psi.OverridableMemberInstance,JetBrains.ReSharper.Psi.IDeclaredType,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType},System.Collections.Generic.List{JetBrains.ReSharper.Psi.OverridableMemberInstance},System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType})">
            <summary>
            find all interfaces of given type (except for ignored ones) which declared given member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IRangeTranslator">
            <summary>
            Document range translator
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.WaitForCaches(System.String,System.String)">
            <summary>
            Syncroniously wait until caches are ready, with a popup progress window.
            Must be called under a read lock.
            </summary>
            <param name="sCallerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="sCancelButtonContent">Title of the Cancel button.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.CreatePointer``1(``0)">
            <summary>
            Creates the smart pointer to the declared element which probably could
            restore the the declared element after massive changes
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.GetGeneratedDocumentService(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the generated code-behind document service (if any) for the given project file.
            If no service is registered for this file, then returns <c>null</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.GetDocumentTextInTransaction(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the document text if tthe transaction will be commited
            </summary>
            <returns><c>null</c> if transaction couldn't be commited</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.DoTransaction(JetBrains.ReSharper.Psi.TransactionHandler,System.Object[])">
            <summary>
            Do PSI write bulk operation.
            Upon success, ensure all modified documents are writable
            </summary>
            <returns>Status of attempt to modify involved documents</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.DoConditionaTransaction(JetBrains.ReSharper.Psi.ConditionalTransactionHandler,System.String,System.Object[])">
            <summary>
            Do PSI write bulk operation. Commit if handler returns true
            Upon success, ensure all modified documents are writable
            </summary>
            <returns>Status of attempt to modify involved documents, or null if hadler returned false</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.AreInternalsVisibleTo(JetBrains.ProjectModel.IModule,JetBrains.ProjectModel.IModule)">
            <summary>
            Checks if internals from <paramref name="moduleFrom"/> are visible to <paramref name="moduleTo"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.AddPsiCache(JetBrains.ReSharper.Psi.Impl.InvalidatingPsiCache)">
            <summary>
            Custom caches for PSIs
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.CachesIdle">
            <summary>
            Indicates if the async cache updater is idle right now
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.IsAccessToUncommittedPsiAllowed">
            <summary>
            Enables clients to access uncommitted PSI files. Can be used because of performance reason e.g.
            when one cannot afford to commit PSI too often
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.myDirtyProjectItems">
            <summary>
            Project items for which PSI is outdated
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.AddTransactionAction(JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiTransactionAction,JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.PsiChangedElementType)">
             <summary>
             Add new transaction action with change in PSI element.
             </summary>
             <param name="action"></param>
             <param name="elementContainingChanges">Element in PSI which incorporates changes in it's children.
             Pass <c>null</c> for major PSI changes</param>
            <param name="changedElementType"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.AddTransactionAction(JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiTransactionAction)">
            <summary>
            Add transaction action with no change in PSI.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.ReParse(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.Util.TextRange,System.String)">
            <summary>
            Incrementally reparse file.
            This is Write-PSI action!
            </summary>
            <param name="file">old file</param>
            <param name="modifiedRange">range in old file which is modified</param>
            <param name="newText">text which should replace the given range</param>
            <returns>The reparsed file. May be equal to the source one</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.IsCurrentTransactionFailed">
            <summary>
            True if FailTransaction method is called, thus the transaction will be rolled back
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.Entry.Optimized">
            <summary>
            If the replaced text is the same at the beginning/ending, then do not modify that portion of text
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap">
            <summary>
            Converts series of sequential document changes to optimized final document change map
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap.FindStartPoint(System.Int32,System.Int32@)">
            <summary>
            Try to find the right segment in the modified document
            Returns true if the point is inside modified segment, and <paramref name="segment"/> contains the segment index
            Returns false if the point is outside modified segment, and <paramref name="segment"/> contains the previous segment index
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap.FindEndPoint(System.Int32,System.Int32@)">
            <summary>
            Try to find the right segment in the modified document
            Returns true if the point is inside modified segment, and <paramref name="segment"/> contains the segment index
            Returns false if the point is outside modified segment, and <paramref name="segment"/> contains the next segment index
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.DeclaredElementPointer">
            <summary>
            Implements element pointer funcitonality
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.DeclaredElementPointer.#ctor(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Creates new smart element pointing to the specified declared element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.TransactionManager">
            <summary>
            Manages nested PSI transactions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.TransactionManager.GetDocumentTextInTransaction(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the document text if tthe transaction will be commited.
            I.e. playback the transaction actions
            </summary>
            <returns><c>null</c> if transaction couldn't be commited</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Reflection2.Parameter.Next">
            <summary>
            Just for optimization. Parameters in methods are stored as single-linked list
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.TypeParameter.FindInheritedTypeParameterOfMethod">
            <summary>
            Tries to find the type parameter of the inherited method.
            According to C# specs 25.6.2
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCacheManagerImpl.SaveFileInCache(JetBrains.ProjectModel.IAssembly,JetBrains.ReSharper.Psi.Caches.ILibraryFile,JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyDataCache)">
            <summary>
            Save assembly data in caches
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCacheManagerImpl.SaveXMLDocIndexInCache(JetBrains.ProjectModel.IAssembly,JetBrains.Util.FileSystemPath,JetBrains.ReSharper.Psi.Impl.Reflection2.XMLDocIndex)">
            <summary>
            Save XML documentation index in caches
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPsiCacheManagerImpl.IsSystemAssembly(JetBrains.ProjectModel.IAssembly)">
            <summary>
            Assembly is couned as system if it is located in framework dir or in GAC
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticEnumMethodsFilter">
            <summary>
            Filters our static methods of class object
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Resolve.ResolveCache">
            <summary>
            Cache the <see cref="T:JetBrains.ReSharper.Psi.Resolve.ResolveResult"/> for the reference.
            According to the resolved <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>, the result is cached either by hard reference,
            either it is cached by weak reference and put into the user data of the delcared element' declaration file 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveUtil.AddDeclarationsForProperDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType,System.Int32,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable,System.Boolean,System.Boolean,JetBrains.Util.DataStructures.HashSetWrapper{JetBrains.ReSharper.Psi.IDeclaredType}@,System.Boolean)">
            "Proper" declared type means that it does not refer to type parameter
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.NarrowSearchDomainByAllWords(JetBrains.ProjectModel.ISolution,JetBrains.ReSharper.Psi.Search.ISearchDomain,System.String[])">
            <summary>
            Narrow search domain to files which contains ALL of the given words
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcher.ProcessProjectItem(JetBrains.ProjectModel.IProjectFile)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcher.ProcessElement(JetBrains.ReSharper.Psi.Tree.IElement)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory">
            <summary>
            Language servide should implement the searcher factory to allow the finder look into files with specific language
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.OverridableSearchHelper">
            <summary>
            Helper class to search overriding/implementing member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeConversionRule">
            <summary>
            This interafce should be provided by language service. See <see cref="T:JetBrains.ReSharper.Psi.LanguageService"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.ArrayOfTokens.FindTokenAt(System.Int32)">
            <summary>
            Finds the token which covers the given position (i.e. pos in [start,end))
            </summary>
            <param name="pos"></param>
            <returns>Token index. Less than 0 if not found</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.DocumentUpdatesAccumulator">
            <summary>
            Accumulates incremental changes in the document
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.LexemIndent">
            <summary>
            Number of lexems that incremental re-lexing should step back to start relexing
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.LookaheadToken(JetBrains.ReSharper.Psi.Parsing.ILexer,System.Int32)">
            <summary>
            Scan next k tokens
            </summary>
            <param name="lexer"></param>
            <param name="k"></param>
            <returns>Type of the k'th token</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.GetCurrTokenText(JetBrains.ReSharper.Psi.Parsing.ILexer)">
            <summary>
            Get the text of the current token of the lexer
            </summary>
            <param name="lexer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScan(JetBrains.Util.TextRange,JetBrains.Util.BufferRange,JetBrains.Application.CheckForInterrupt)">
            <summary>
            Rescans the buffer incrementally
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScanInternalIncremental(JetBrains.Util.TextRange,System.Int32,JetBrains.Application.CheckForInterrupt)">
            <returns>Range in document covering all changed tokens.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScanInternalFull(JetBrains.Util.TextRange,System.Int32,JetBrains.Application.CheckForInterrupt)">
            <returns>Range in document covering all changed tokens.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.BufferRange">
            <summary>
            Obtain the range in the <see cref="P:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.Buffer"/> on which the token are cached
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegral(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, char or string
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegralNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsSimplePredefined(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.CanHasUserDefinedOperators(JetBrains.ReSharper.Psi.IType)">
            <summary>
            For optimization and fixing some problems
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeInferenceUtil.MethodGroupImplicitInference(JetBrains.ReSharper.Psi.IMethod,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.IDelegate,JetBrains.ReSharper.Psi.Resolve.ISubstitution,System.Boolean)">
            <summary>
            Infers values for method type parameters. Returns 'null' if inference fails, methodSubstitution 
            extended with type parameter values if it succeeds
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.OnCachesChanged(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Invalidate cache on Cache change
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Determines if the given <paramref name="subType"/> is the descendant of the <paramref name="superType"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.ArrayTypePointer">
            <summary>
            Holds pointer to an array type 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeDecorator">
            <summary>
            A type pointer which decorates another type pointer
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypePointer">
            <summary>
            Interface for obtaining a type from some place
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypePointer.FindType">
            <summary>
            Resurrects the type being pointed to
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypePointer.Solution">
            <summary>
            Solution in which the pointer was created
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeDecorator.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.ArrayTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>  
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypePointer">
            <summary>
            Type pointer for a declared type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPointerType">
            <summary>
            Interface for unsafe code pointer type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPointerType.ElementType">
            <summary>
            Obtaing the underlying type, that is type of the element on which this pointer points.
            Example: for "int*" returns "int".
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.PointerTypePointer">
            <summary>
            Points to a pointer type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.PointerTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary> 
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Reflection2.XMLDocIndex.myHash">
            <summary>
            Map from hash code of member ID to list of ranges in file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.InvocableSignature">
            <summary>
            The signature (name + parameters) of IInvocable. Signature is used to identify matching
            invocables, that is to say, invocables which have the same set of parameters and the identical name.
            </summary>
            Two InvocableSignature's are equal if they have the same name, parameter types and parameter kinds.
            Methods <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> are implemented 
            by this class to match the above definition.
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.Null">
            <summary>
            Instance of InvocableSignature that can be used as null value
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.#ctor(JetBrains.ReSharper.Psi.IParametersOwner,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType)">
            <summary>
            Creates signature by an IInvocable. It's better to use <see cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>.
            </summary>
            <param name="parametersOwner">Invocable to create signature for</param>
            <param name="substitution"></param>
            <param name="parameterKindCompareType"></param>
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.GetParameterType(System.Int32)">
            <summary>
            Type of parameter with index <c>parameterIndex</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.GetParameterKind(System.Int32)">
            <summary>
            Kind of parameter with index <c>parameterIndex</c>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.Name">
            <summary>
            Name of IInvocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.ParameterCount">
            <summary>
            Parameter count of IInvocable
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:JetBrains.ReSharper.Psi.InvocableSignature.EqualitySubstitution" -->
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType.STRICT">
            <summary>
            Strict parameter kind comparing, i.e. value, out and ref are all different
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType.VB_LIKE">
            <summary>
            Visual-Basic parameter kind comparing, where 'out' and 'ref' kinds are the same
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.ShouldInvalidatePsiCache(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.PsiChangedElementType)">
            <summary>
            Check if the PSI caches should be invalidated on this change
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.GetDeclaredElementImage(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Get the language-specific image for the given declared element.
            Returned image should be without extensions
            </summary>
            <param name="declaredElement"></param>
            <returns>Image, or <c>null</c> if to use default image</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.IsTypeMemberVisible(JetBrains.ReSharper.Psi.ITypeMember)">
            <summary>
            Check if the given type member is visible in this language
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.CodeFormatter">
            <summary>
            Get the code formatter
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.DeclaredElementPresenter">
            <summary>
            Provide language-specific presentation of the declared elements.
            Returns <c>null</c> if default presenter should be used
            </summary>
            You should never call this method directly. Use <cref>DeclaredElementPresenter.Format</cref>> instead.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.IParser">
            <summary>
            Abstract parser interface
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.ParserService">
            <summary>
            Utility class for accessing Parsing services
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TemporaryChangeCookie">
            <summary>
            Transaction for temporary change
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PhysicalChangeCookie">
            <summary>
            Transaction, that will commit
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ControlledTransactionCookie">
            <summary>
            Controls that each and every transaction is either committed or rolled back
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ISupportedByPSIChecker">
            <summary>
            Additional checking of whether given project file should be supported bu PSI
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ISupportedByPSIChecker.Check(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            If any of the registered checked answer <c>true</c> for the given project file, then PSI will be built
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Search.SearchAction">
            <summary>
            Handy class for running search actions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.SUCCESS">
            <summary>
            Transaction succeded
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.FAILURE">
            <summary>
            Transaction failed due to some internal reasons
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.CANCELLED">
            <summary>
            Transaction failed due to ProcessCancelledException is caught (usually, user press "cancel" button in progress window
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_FAILURE">
            <summary>
            The attempt to ensure writable failed for some files
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_CHANGES_DETECTED">
            <summary>
            Some files were modified as a result of the attempt to make them writable
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_HAS_HIDDEN_FILES">
            <summary>
            There are hidden file, that cannot be modified, since they are generated by external build provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeFactory.CreateType(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.IType[])">
            <summary>
            Creates a declared type for a given type element with given type parametre values
            </summary>
            Type parameter values should be specified for all type parameters of type element and its containing 
            type elements. They should appear in typeParameterValues array in outer-class-first, left-to-right order
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypePointerFactory">
            <summary>
            Class for creating type pointers on types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.PersistentDataElementCollector`1">
            <summary>
            Collects all elements which have a data by the specified key
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TextToPsi.SelectReference(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.DocumentRange,JetBrains.ReSharper.Psi.Resolve.IReference[])">
            <summary>
            Selects a reference that user is most likely to bear in mind
            </summary>
            <remarks>Generally, we prefer references to the right of the position</remarks>
        </member>
    </members>
</doc>
