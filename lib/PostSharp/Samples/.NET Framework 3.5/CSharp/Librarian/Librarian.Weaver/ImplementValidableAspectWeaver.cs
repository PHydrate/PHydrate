#region Released to Public Domain by Gael Fraiteur
/*----------------------------------------------------------------------------*
 *   This file is part of samples of PostSharp.                                *
 *                                                                             *
 *   This sample is free software: you have an unlimited right to              *
 *   redistribute it and/or modify it.                                         *
 *                                                                             *
 *   This sample is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                      *
 *                                                                             *
 *----------------------------------------------------------------------------*/
#endregion

using System;
using System.Reflection;
using Librarian.Framework;
using PostSharp.Aspects;
using PostSharp.Sdk.AspectInfrastructure;
using PostSharp.Sdk.AspectWeaver;
using PostSharp.Sdk.AspectWeaver.AspectWeavers;
using PostSharp.Sdk.AspectWeaver.Transformations;
using PostSharp.Sdk.CodeModel;
using PostSharp.Sdk.CodeModel.Helpers;
using PostSharp.Sdk.Collections;
using PostSharp.Extensibility;

namespace Librarian.Weaver
{
    /// <summary>
    /// Generate code (specifically the <see cref="BaseEntity.AutoGeneratedValidate"/> method)
    /// for the 'Validate' aspect.
    /// </summary>
    internal class ImplementValidableAspectWeaver : TypeLevelAspectWeaver
    {
        private ImplementValidableAspectTransformation transformation;
        public ImplementValidableAspectWeaver( ) : base( null, MulticastTargets.Class )
        {
        }

        protected override AspectWeaverInstance CreateAspectWeaverInstance( AspectInstanceInfo aspectInstanceInfo )
        {
            return new ImplementValidableAspectWeaverInstance( this, aspectInstanceInfo );
        }

        protected override void Initialize()
        {
            base.Initialize();
            this.transformation = new ImplementValidableAspectTransformation( this);
            this.ApplyWaivedEffects(this.transformation);
        }

      

        class ImplementValidableAspectWeaverInstance : TypeLevelAspectWeaverInstance
        {
            private ImplementValidableAspectWeaver parent;
            public ImplementValidableAspectWeaverInstance(ImplementValidableAspectWeaver parent, AspectInstanceInfo aspectInstanceInfo)
                : base(parent, aspectInstanceInfo)
            {
                this.parent = parent;
            }

            public override void ProvideAspectTransformations( AspectWeaverTransformationAdder adder )
            {
                adder.Add( this.TargetElement, this.parent.transformation.CreateInstance(this) );
            }
        }

    }

    internal class ImplementValidableAspectTransformation : StructuralTransformation
    {
        public ImplementValidableAspectTransformation( AspectWeaver aspectWeaver ) : base( aspectWeaver )
        {
        }

        public AspectWeaverTransformationInstance CreateInstance(AspectWeaverInstance aspectWeaverInstance)
        {
            return new ImplementValidableAspectTransformationInstance( this, aspectWeaverInstance );
        }

        class ImplementValidableAspectTransformationInstance : StructuralTransformationInstance
        {
            public ImplementValidableAspectTransformationInstance( StructuralTransformation parent, AspectWeaverInstance aspectWeaverInstance ) : base( parent, aspectWeaverInstance )
            {
            }

            public override void Implement(TransformationContext context)
            {
                
                ModuleDeclaration module = this.AspectWeaver.Module;

                TypeDefDeclaration typeDef = (TypeDefDeclaration)context.TargetElement;

                // Declare the method.
                MethodDefDeclaration methodDef = new MethodDefDeclaration
                {
                    Name = "AutoGeneratedValidate",
                    Attributes = (MethodAttributes.Family | MethodAttributes.ReuseSlot | MethodAttributes.Virtual),
                    CallingConvention = CallingConvention.HasThis
                };
                typeDef.Methods.Add(methodDef);
                methodDef.CustomAttributes.Add(this.AspectWeaver.AspectInfrastructureTask.WeavingHelper.GetDebuggerNonUserCodeAttribute());

                // Define parameter.
                methodDef.ReturnParameter = new ParameterDeclaration
                {
                    ParameterType = module.Cache.GetIntrinsic(IntrinsicType.Void),
                    Attributes = ParameterAttributes.Retval
                };

                // Define the body
                MethodBodyDeclaration methodBody = new MethodBodyDeclaration();
                methodDef.MethodBody = methodBody;
                InstructionBlock instructionBlock = methodBody.CreateInstructionBlock();
                methodBody.RootInstructionBlock = instructionBlock;
                InstructionSequence sequence = methodBody.CreateInstructionSequence();
                instructionBlock.AddInstructionSequence(sequence, NodePosition.After, null);

                using (InstructionWriter writer = new InstructionWriter())
                {
                    writer.AttachInstructionSequence( sequence );

                    // Find the base method.
                    IMethod baseValidateMethod = null;
                    IType baseTypeCursor = typeDef.BaseType;
                    MethodSignature methodSignature =
                        new MethodSignature( module, CallingConvention.HasThis, module.Cache.GetIntrinsic( IntrinsicType.Void ),
                                             new ITypeSignature[0], 0 );

                    while ( baseValidateMethod == null )
                    {
                        TypeDefDeclaration baseTypeCursorTypeDef = baseTypeCursor.GetTypeDefinition();

                        baseValidateMethod =
                            baseTypeCursorTypeDef.Methods.GetMethod( "AutoGeneratedValidate",
                                                                     methodSignature.Translate( baseTypeCursorTypeDef.Module ),
                                                                     BindingOptions.OnlyExisting |
                                                                     BindingOptions.DontThrowException );

                        baseTypeCursor = baseTypeCursorTypeDef.BaseType;
                    }

                    // TODO: support generic base types.

                    // Call the base method.
                    writer.EmitInstruction( OpCodeNumber.Ldarg_0 );
                    writer.EmitInstructionMethod( OpCodeNumber.Call, (IMethod) baseValidateMethod.Translate( typeDef.Module ) );

                    // Make an array with the boxed field values.
                    TypeValidationAspect aspect = (TypeValidationAspect) this.AspectWeaverInstance.Aspect;
                    LocalVariableSymbol fieldValuesArrayLocal = instructionBlock.DefineLocalVariable(
                        module.Cache.GetType( typeof(object[]) ), "fieldValues" );
                    writer.EmitInstructionInt32( OpCodeNumber.Ldc_I4, aspect.Validators.Count );
                    writer.EmitInstructionType( OpCodeNumber.Newarr, module.Cache.GetIntrinsic( IntrinsicType.Object ) );
                    writer.EmitInstructionLocalVariable( OpCodeNumber.Stloc, fieldValuesArrayLocal );

                    int i = 0;
                    foreach ( FieldValidationAttribute validator in aspect.Validators )
                    {
                        FieldDefDeclaration fieldDef = typeDef.Fields.GetByName( validator.TargetLocation.Name );
                        IField fieldSpec = GenericHelper.GetFieldCanonicalGenericInstance( fieldDef );

                        writer.EmitInstructionLocalVariable( OpCodeNumber.Ldloc, fieldValuesArrayLocal );
                        writer.EmitInstructionInt32( OpCodeNumber.Ldc_I4, i );
                        writer.EmitInstruction( OpCodeNumber.Ldarg_0 );
                        writer.EmitInstructionField( OpCodeNumber.Ldfld, fieldSpec );
                        writer.EmitConvertToObject( fieldSpec.FieldType );
                        writer.EmitInstruction( OpCodeNumber.Stelem_Ref );

                        i++;
                    }

                    // Get the validator method.
                    IMethod validateMethod = module.Cache.GetItem(
                        () => module.FindMethod(
                                  typeof(TypeValidationAspect).GetMethod( "Validate" ),
                                  BindingOptions.Default ) );

                    // Call the validator.
                    this.AspectWeaverInstance.AspectRuntimeInstanceField.EmitLoadField( writer, null );
                    writer.EmitInstructionLocalVariable( OpCodeNumber.Ldloc, fieldValuesArrayLocal );
                    writer.EmitInstructionMethod( OpCodeNumber.Callvirt, validateMethod );

                    writer.EmitInstruction( OpCodeNumber.Ret );
                    writer.DetachInstructionSequence();
                }
            }
        }

        public override string GetDisplayName( MethodSemantics semantic )
        {
            return "Implement Validation";
        }
    }
}